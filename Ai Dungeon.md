# Архитектура проекта Dungeon Master AI на LangGraph

#LangGraph #AI #GameDev #RPG #Архитектура

## Основная концепция

Цель этой архитектуры — перенести существующую игру в жанре RPG, построенную на классической state-machine, на платформу **LangGraph**. Это позволит создать более гибкий, модульный и управляемый ИИ игровой цикл. Вместо стека состояний (`state_stack`), управляемого в Python, мы будем использовать граф состояний (`StateGraph`), где каждый узел представляет собой ключевой аспект игрового процесса.

**Состояние графа (`GraphState`)** будет служить единым источником правды, хранящим сериализованное состояние всей игры в формате JSON. Это позволяет графу быть полностью `stateful` и продолжать выполнение с того места, где он остановился.

## Состояние графа (GraphState)

`GraphState` — это центральный объект данных, который передается между всеми узлами. Он инкапсулирует всё, что нужно знать об игровом мире в любой момент времени.

typescript

`interface GraphState {   // Полное состояние игры, сериализованное в JSON.   // Включает данные игрока, карты, NPC, квесты и т.д.   gameState: string;   // Последний ввод пользователя (команда).   userInput: string;   // Ответ, который будет показан пользователю.   // Генерируется узлами графа.   llmOutput: string;   // Ключ для маршрутизации, определяющий, какой узел будет следующим.   nextNode: "MapEngine" | "CombatEngine" | "DialogEngine" | "SystemEngine" | "__FINISH__"; }`

## Узлы графа (Nodes)

Каждый узел в графе — это функция или класс, отвечающий за определенную часть игровой логики. Он принимает на вход `GraphState`, выполняет свою работу и возвращает обновленное состояние.

## 1. `InitializerNode` (Узел инициализации)

Это входная точка графа (`entry_point`). Его задача — подготовить игру к запуску.

- **Логика:**
    
    1. Проверяет `gameState` в состоянии графа.
        
    2. Если `gameState` пуст, создает новый экземпляр игры (новый персонаж, стартовая локация).
        
    3. Если `gameState` содержит данные, загружает их, воссоздавая объект игры (`Game.from_dict`).
        
    4. Генерирует приветственное сообщение.
        
- **Маршрутизация:** Всегда передает управление узлу `MapEngineNode`.
    

## 2. `MapEngineNode` (Узел игрового мира и исследования)

Это основной узел, отвечающий за исследование мира, передвижение и взаимодействие с окружением.

- **Логика:**
    
    1. Десериализует `gameState` в полноценный объект игры.
        
    2. Обрабатывает команды пользователя, связанные с исследованием: `go north`, `look`, `examine object`, `open door`.
        
    3. Вызывает соответствующие методы игрового движка (`giocatore.muovi`, `oggetto.interagisci`).
        
    4. После выполнения команды проверяет триггеры:
        
        - Если игрок сталкивается с врагом, устанавливает `nextNode = "CombatEngine"`.
            
        - Если игрок пытается поговорить с NPC, устанавливает `nextNode = "DialogEngine"`.
            
        - Если игрок использует системную команду (`save`, `inventory`), устанавливает `nextNode = "SystemEngine"`.
            
- **Маршрутизация:** По умолчанию остается на этом же узле, но меняет `nextNode` при срабатывании триггеров.
    

## 3. `DialogEngineNode` (Узел диалогов)

Этот узел активируется, когда игрок вступает в диалог с NPC.

- **Логика:**
    
    1. Десериализует `gameState` и определяет, с каким NPC идет диалог.
        
    2. Управляет логикой диалога, используя данные из `data/npc/conversations.json`.
        
    3. Обрабатывает выборы игрока в диалоге.
        
    4. Когда диалог завершается (игрок прощается или диалог логически заканчивается), узел завершает свою работу.
        
- **Маршрутизация:** После завершения диалога всегда устанавливает `nextNode = "MapEngine"`, чтобы вернуть игрока в режим исследования.
    

## 4. `CombatEngineNode` (Узел боя)

Этот узел управляет пошаговыми сражениями.

- **Логика:**
    
    1. Десериализует `gameState` для получения данных об игроке и врагах.
        
    2. Реализует боевой цикл: ход игрока, ход врага.
        
    3. Обрабатывает команды игрока: `attack`, `defend`, `use potion`.
        
    4. Рассчитывает действия врага (может использовать простой AI или вызов LLM для более сложных тактик).
        
    5. Бой продолжается до тех пор, пока одна из сторон не будет побеждена.
        
- **Маршрутизация:** После окончания боя (победа или поражение) устанавливает `nextNode = "MapEngine"`.
    

## 5. `SystemEngineNode` (Системный узел)

Обрабатывает мета-команды, не связанные напрямую с игровым миром.

- **Логика:**
    
    1. Обрабатывает команды `save`, `load`, `inventory`, `help`, `quit`.
        
    2. Вызывает соответствующие методы игрового движка, например `game.salva()`.
        
    3. Формирует системный ответ (например, "Игра сохранена" или список предметов в инвентаre).
        
- **Маршрутизация:** После выполнения команды всегда возвращает управление в `MapEngineNode`.
    

## Рёбра и маршрутизация (Edges and Routing)

Маршрутизация между узлами определяется условными рёбрами. После каждого узла вызывается функция-маршрутизатор, которая читает поле `nextNode` из `GraphState` и решает, какой узел вызывать следующим.

python

`def route_game(state: GraphState):     next_node = state.get("nextNode", "MapEngine")     return next_node`

Эта функция будет подключена ко всем узлам, создавая динамический цикл, который может переходить от исследования к диалогу, затем к бою и обратно к исследованию.

## Пример рабочего процесса

1. **Пользователь:** `go north`
    
2. **`MapEngineNode`** активен. Он обновляет координаты игрока в `gameState`.
    
3. На новой позиции находится NPC `Durnan`. Узел генерирует ответ: "Вы подходите к Дурнану, хозяину таверны. Он протирает стойку." `nextNode` остается `"MapEngine"`.
    
4. **Пользователь:** `talk`
    
5. **`MapEngineNode`** обрабатывает команду. Он определяет, что игрок хочет поговорить с ближайшим NPC.
    
6. Узел устанавливает `nextNode = "DialogEngine"` и сохраняет информацию о том, с кем начат диалог, в `gameState`.
    
7. **Маршрутизатор** направляет поток к **`DialogEngineNode`**.
    
8. **`DialogEngineNode`** берет управление, загружает первую реплику Дурнана и варианты ответов, отправляя их пользователю. Цикл диалога продолжается внутри этого узла.
    
9. **Пользователь:** "До свидания."
    
10. **`DialogEngineNode`** завершает диалог и устанавливает `nextNode = "MapEngine"`.
    
11. **Маршрутизатор** возвращает управление в режим исследования.
    

## Преимущества этой архитектуры

- **Модульность:** Каждый аспект игры (бой, диалог, исследование) инкапсулирован в своем узле.
    
- **Наблюдаемость:** LangGraph предоставляет отличные инструменты для визуализации и отладки потока состояний.
    
- **Гибкость ИИ:** Легко интегрировать вызовы к LLM в любой узел. Например, `DialogEngineNode` может генерировать ответы NPC на лету, а `CombatEngineNode` — использовать LLM для тактических решений врагов.
    
- **Устойчивость:** Состояние игры полностью сохраняется в `GraphState`, что делает систему устойчивой к сбоям и позволяет легко реализовать сохранение/загрузку.