**В первую очередь** нужно выделить основные правила работы с `СКД`.
Первое и самое важное для понимание правило затрагивает 2 основные в `СКД` вкладки:
*Наборы данных* - место для первичного формирования запроса, от простого до сложного.
*Настройки* - место для обработки результата нашего запроса созданного в *НД*.

Для лучшего понимания проведем чуть более подробную аналогию, где *Наборы данных* будет тождественны `Запросу`, а *Настройки* его `Обработке`. 

**Аналогия**:
Возьмем за пример написание собственной обработки, в которой у нас имеется 1 `ТаблицаЗначений` "*ТЗ*" и 1 `Команда` "*Заполнить ТЗ*".
*ТЗ* содержит 2 условных колонки: Наименование и Номер. Их необходимо заполнить данными, которые мы получим с помощью запроса к *ИБ* . 

***НАБОРЫ ДАННЫХ***
==Пример запроса:==
`"ВЫБРАТЬ`
	`|	Контрагенты.НаименованиеПолное КАК Наименование,`
	`|	Контрагенты.РегистрационныйНомер КАК Номер`
	`|ИЗ`
	`|	Справочник.Контрагенты КАК Контрагенты";`
	
> Здесь мы запросом получаем нужные нам данные!
> Но, сырой запрос просто получает данные, не двигая их, никуда не записывая и не производя вообще никаких манипуляций с ними.
> Для обработки полученных данных нужно прописывать отдельный метод.

***НАСТРОЙКИ СКД***
==Пример обработки данных из запроса:==
`Пока ВыборкаДетальныеЗаписи.Следующий() Цикл`
	`НоваяСтрока = ТЗ.Добавить();`
	`НоваяСтрока.Наименование = ВыборкаДетальныеЗаписи.Наименование;`
	`НоваяСтрока.Номер = ВыборкаДетальныеЗаписи.Номер;`		
	`КонецЦикла;`

А уже здесь мы непосредственно заполняем нашу `ТаблицаЗначений`, используя полученные из запроса данные. Конкретно в этом случае, мы используем обработку внутри цикла. Настройки СКД в свою очередь могут использовать другие механизмы и возможности платформы 1С, но основной принцип `Запрос -> ОбработкаЗапроса` остается неизменным.

По такому же принципу работает `СКД`.
Сначала производиться формирование запроса на вкладке *Наборы данных*, а после его обработка в *Настройках*. 


Блябля по быстрому накатаю, про **лефт джоины** и проблемы дублирования строк.
Крч обычный **лефт джоин** соединяет нахуй все, что видит не проводя агрегацию данных до соединения, он это делает уже после. 
А `СКД` агрегирует их *ДО*, понял? И типа автономно - это важно.
Он склейкой занимается уже *ПОСЛЕ* того как посчитал суммы из регистров и записал их в оперативку, поэтому его **лефт джоины** всегда правильные. 

==Типа если у нас есть условные таблицы которые надо посчитать:==

| ЗаказыКлиентов |        |
| -------------- | ------ |
| Заказ 1        | 10 000 |
| Заказ 2        | 5 000  |

| ОплатаЗаказов |       |
| ------------- | ----- |
| Заказ 1       | 3 000 |
| Заказ 1       | 7 000 |
| Заказ 2       | 5 000 |

Просто **лефт джоин** выведет все, что найдет и у нас в результате их соединения - будет *ДВА* первых заказа и *ОДИН* второй. Потому что по `левому соединению` при нахождении совпадений в сравнительной таблице, **он всегда будет создавать** еще одну строну с основной таблицы - ну типа, совпадение же найдено, значит надо показать.

А внутри `СКД` - он посчитает `Сумму` каждого регистра - **отдельно** и в итоговую таблицу попадут **НЕ прямые данные с регистра, а уже агрегированные!** Именно поэтому никакого дублирования строк не произойдет, потому что никаких `Заказ 1 - 3 000, Заказ 2 - 7 000` уже не существует, уже существует только `Сумма` по `Заказ 1`, а она ровняется `10 000`. 
==И еще раз:== **СКД КЛЕИТ ПОСЧИТАННЫЕ С РЕГИСТРОВ СУММЫ, А НЕ ЧИСТЫЕ ДАННЫЕ.**